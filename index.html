<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />
        <meta name="color-scheme" content="light dark" />
        <title>Plates</title>

        <style>
            @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

            * {
                box-sizing: border-box;
                image-rendering: pixelated;
            }

            :root {
                --bg: #e8e4d9;
                --bg-alt: #d4cfc2;
                --fg: #2a2a2a;
                --fg-muted: #5a5a5a;
                --border: #2a2a2a;
                --accent: #4a7c59;
                --danger: #a63d40;
                --shadow: #1a1a1a;
            }

            @media (prefers-color-scheme: dark) {
                :root {
                    --bg: #1a1a2e;
                    --bg-alt: #16213e;
                    --fg: #e8e4d9;
                    --fg-muted: #8a8a9a;
                    --border: #e8e4d9;
                    --accent: #7ec8a3;
                    --danger: #e76f6f;
                    --shadow: #0a0a15;
                }
            }

            html {
                font-family: 'VT323', monospace;
                font-size: 18px;
                line-height: 1.2;
                background: var(--bg);
                color: var(--fg);
            }

            body {
                margin: 0;
                padding: 12px;
                max-width: 420px;
                margin-inline: auto;
            }

            h1 {
                font-size: 1.4rem;
                margin: 0 0 8px 0;
                font-weight: normal;
                letter-spacing: 2px;
                text-transform: uppercase;
            }

            .muted {
                color: var(--fg-muted);
            }

            .mono {
                font-family: 'VT323', monospace;
                font-variant-numeric: tabular-nums;
            }

            .danger {
                color: var(--danger);
            }

            /* Pixel border mixin */
            .pixel-box {
                border: 2px solid var(--border);
                box-shadow:
                    4px 4px 0 var(--shadow),
                    inset -1px -1px 0 var(--fg-muted),
                    inset 1px 1px 0 var(--bg);
            }

            /* Inputs row */
            .inputs-row {
                display: flex;
                gap: 8px;
                margin-bottom: 10px;
            }

            .input-group {
                flex: 1;
                display: flex;
                align-items: center;
                gap: 4px;
            }

            .input-group label {
                font-size: 0.9rem;
                color: var(--fg-muted);
                min-width: 42px;
                text-transform: uppercase;
                letter-spacing: 1px;
            }

            .input-wrap {
                flex: 1;
                display: flex;
                gap: 4px;
            }

            input[type="text"],
            input[type="number"] {
                font-family: 'VT323', monospace;
                font-size: 1.1rem;
                padding: 4px 6px;
                border: 2px solid var(--border);
                border-radius: 0;
                background: var(--bg);
                color: var(--fg);
                width: 100%;
                box-shadow: inset 2px 2px 0 var(--shadow);
            }

            input:focus {
                outline: none;
                background: var(--bg-alt);
                box-shadow: inset 2px 2px 0 var(--shadow), 0 0 0 1px var(--accent);
            }

            button {
                font-family: 'VT323', monospace;
                font-size: 1.1rem;
                padding: 4px 8px;
                border: 2px solid var(--border);
                border-radius: 0;
                background: var(--bg-alt);
                color: var(--fg);
                cursor: pointer;
                line-height: 1;
                box-shadow: 2px 2px 0 var(--shadow);
                text-transform: uppercase;
                transition: none;
            }

            button:hover {
                background: var(--accent);
                color: var(--bg);
            }

            button:active {
                box-shadow: none;
                transform: translate(2px, 2px);
            }

            .clear-btn {
                padding: 4px 6px;
                min-width: 28px;
            }

            /* Results */
            .results {
                margin-bottom: 10px;
                padding: 8px;
                background: var(--bg-alt);
                border: 2px solid var(--border);
                box-shadow: 4px 4px 0 var(--shadow);
            }

            .result-main {
                font-size: 1.5rem;
                margin-bottom: 4px;
                color: var(--accent);
            }

            .result-line {
                margin: 2px 0;
                font-size: 1rem;
            }

            /* Plate table */
            .plate-table {
                border: 2px solid var(--border);
                box-shadow: 4px 4px 0 var(--shadow);
                font-size: 1rem;
            }

            .plate-head {
                display: grid;
                grid-template-columns: 1fr 1fr 32px;
                gap: 6px;
                padding: 6px 8px;
                background: var(--border);
                color: var(--bg);
                text-transform: uppercase;
                letter-spacing: 1px;
            }

            .plate-row {
                display: grid;
                grid-template-columns: 1fr 1fr 32px;
                gap: 6px;
                padding: 4px 8px;
                align-items: center;
                background: var(--bg);
            }

            .plate-row:nth-child(even) {
                background: var(--bg-alt);
            }

            .plate-row input {
                padding: 2px 4px;
                font-size: 1rem;
            }

            .plate-row button {
                padding: 2px 4px;
                min-width: 24px;
                font-size: 1rem;
                box-shadow: 1px 1px 0 var(--shadow);
            }

            .plate-row button:active {
                transform: translate(1px, 1px);
                box-shadow: none;
            }

            .plate-footer {
                border-top: 2px dashed var(--border);
                background: var(--bg) !important;
            }

            /* Footer */
            .footer {
                margin-top: 10px;
                display: flex;
                justify-content: flex-end;
            }

            .btn-reset {
                font-size: 0.9rem;
                padding: 4px 10px;
                background: var(--bg);
            }

            .btn-reset:hover {
                background: var(--danger);
            }

            /* Scrollbar styling for that retro feel */
            ::-webkit-scrollbar {
                width: 12px;
            }
            ::-webkit-scrollbar-track {
                background: var(--bg-alt);
                border: 2px solid var(--border);
            }
            ::-webkit-scrollbar-thumb {
                background: var(--border);
            }
        </style>
    </head>

    <body>
        <h1>&gt; Plates_</h1>

        <div class="inputs-row">
            <div class="input-group">
                <label for="targetWeight">Total</label>
                <div class="input-wrap">
                    <input
                        id="targetWeight"
                        class="mono"
                        type="text"
                        inputmode="decimal"
                        placeholder="112"
                    />
                    <button
                        id="clearTarget"
                        type="button"
                        class="clear-btn"
                        aria-label="Clear total"
                    >
                        &times;
                    </button>
                </div>
            </div>

            <div class="input-group">
                <label for="barWeight">Bar</label>
                <div class="input-wrap">
                    <input
                        id="barWeight"
                        class="mono"
                        type="text"
                        inputmode="decimal"
                        placeholder="25"
                    />
                    <button
                        id="clearBar"
                        type="button"
                        class="clear-btn"
                        aria-label="Clear bar"
                    >
                        &times;
                    </button>
                </div>
            </div>
        </div>

        <div id="results" class="results" aria-live="polite">
            <span class="muted">&mdash;</span>
        </div>

        <div class="plate-table">
            <div class="plate-head">
                <div>Weight</div>
                <div>Available</div>
                <div></div>
            </div>

            <div id="inventory"></div>

            <div class="plate-row plate-footer">
                <div>
                    <input
                        id="newWeight"
                        class="mono"
                        type="text"
                        inputmode="decimal"
                        placeholder="Weight"
                        aria-label="New plate weight"
                    />
                </div>
                <div>
                    <input
                        id="newAvailable"
                        class="mono"
                        type="number"
                        inputmode="numeric"
                        min="0"
                        placeholder="Qty"
                        aria-label="New plate quantity"
                    />
                </div>
                <div>
                    <button
                        id="addPlate"
                        type="button"
                        aria-label="Add plate"
                    >
                        +
                    </button>
                </div>
            </div>
        </div>

        <div class="footer">
            <button id="resetApp" type="button" class="btn-reset">Reset</button>
        </div>

        <script>
            (() => {
                "use strict";

                const STORAGE_KEY = "platesAppSettings.v7";

                const DEFAULT_INVENTORY = [
                    [25, 4],
                    [20, 4],
                    [15, 4],
                    [10, 4],
                    [5, 8],
                    [2.5, 8],
                    [1.5, 8],
                    [1.25, 8],
                ];

                const DEFAULT_BAR = 25;
                const DEFAULT_TARGET = 112;

                const $ = (id) => document.getElementById(id);
                const el = {
                    target: $("targetWeight"),
                    bar: $("barWeight"),
                    clearTarget: $("clearTarget"),
                    clearBar: $("clearBar"),
                    inventory: $("inventory"),
                    results: $("results"),
                    newWeight: $("newWeight"),
                    newAvailable: $("newAvailable"),
                    addPlate: $("addPlate"),
                    reset: $("resetApp"),
                };

                let state = {
                    targetWeight: String(DEFAULT_TARGET),
                    barWeight: DEFAULT_BAR,
                    plates: [],
                };

                const uid = () =>
                    "p_" +
                    Math.random().toString(16).slice(2) +
                    "_" +
                    Date.now().toString(16);

                const normalizeNumberString = (v) => {
                    if (v == null) return "";
                    let s = String(v).trim();
                    if (!s) return "";
                    s = s.replace(/\s+/g, "");
                    return s.replace(/,/g, ".");
                };

                const parseLocaleNumber = (v) =>
                    Number(normalizeNumberString(v));

                const clampInt = (v) => {
                    const n = parseLocaleNumber(v);
                    return Number.isFinite(n) ? Math.max(0, Math.floor(n)) : 0;
                };

                const SCALE = 100;
                const toInt = (v) => {
                    const n = parseLocaleNumber(v);
                    return Number.isFinite(n) ? Math.round(n * SCALE) : NaN;
                };
                const fromInt = (n) => n / SCALE;

                const fmt = (n) => {
                    if (!Number.isFinite(n)) return "—";
                    const s = (Math.round(n * 100) / 100).toFixed(2);
                    return s.replace(/\.00$/, "").replace(/(\.\d)0$/, "$1");
                };

                const byWeightDesc = (a, b) => b.weight - a.weight;

                const initialPlates = () =>
                    DEFAULT_INVENTORY.map(([w, available]) => ({
                        id: uid(),
                        weight: w,
                        available,
                    })).sort(byWeightDesc);

                function normalizePlates(plates) {
                    return plates
                        .filter(
                            (p) =>
                                Number.isFinite(p.weight) &&
                                p.weight > 0 &&
                                clampInt(p.available) >= 0
                        )
                        .map((p) => ({
                            id: p.id || uid(),
                            weight: Number(p.weight),
                            available: clampInt(p.available),
                        }))
                        .sort(byWeightDesc);
                }

                function save() {
                    const payload = {
                        targetWeight: state.targetWeight,
                        barWeight: state.barWeight,
                        plates: state.plates.map((p) => ({
                            id: p.id,
                            weight: p.weight,
                            available: p.available,
                        })),
                    };
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
                }

                function resetStateToDefaults() {
                    state = {
                        targetWeight: String(DEFAULT_TARGET),
                        barWeight: DEFAULT_BAR,
                        plates: initialPlates(),
                    };
                }

                function load() {
                    const raw = localStorage.getItem(STORAGE_KEY);
                    if (!raw) {
                        resetStateToDefaults();
                        return;
                    }
                    try {
                        const parsed = JSON.parse(raw);
                        state.targetWeight =
                            parsed.targetWeight ?? String(DEFAULT_TARGET);
                        state.barWeight =
                            parsed.barWeight === "" || parsed.barWeight == null
                                ? ""
                                : Number(parsed.barWeight ?? DEFAULT_BAR);

                        const plates = Array.isArray(parsed.plates)
                            ? parsed.plates
                            : [];
                        state.plates = normalizePlates(plates);
                        if (!state.plates.length)
                            state.plates = initialPlates();
                    } catch {
                        resetStateToDefaults();
                    }
                }

                function syncInputs() {
                    el.target.value = state.targetWeight;
                    el.bar.value =
                        state.barWeight === ""
                            ? ""
                            : Number.isFinite(state.barWeight)
                              ? state.barWeight
                              : "";
                    el.newWeight.value = "";
                    el.newAvailable.value = "";
                }

                function computeBest(targetTotal, barWeight, plates) {
                    if (
                        !Number.isFinite(targetTotal) ||
                        !Number.isFinite(barWeight)
                    )
                        return { kind: "invalid" };

                    if (targetTotal < 0 || barWeight < 0)
                        return { kind: "invalid" };

                    const targetI = toInt(targetTotal);
                    const barI = toInt(barWeight);
                    if (!Number.isFinite(targetI) || !Number.isFinite(barI))
                        return { kind: "invalid" };

                    const needTotalI = Math.max(0, targetI - barI);

                    if (needTotalI <= 0) {
                        return {
                            kind: "below-bar",
                            targetTotal,
                            achievedTotal: barWeight,
                            overBy: barWeight - targetTotal,
                            usagePerSide: [],
                        };
                    }

                    const needPerSideI = Math.ceil(needTotalI / 2);

                    const types = plates
                        .map((p) => ({
                            wI: toInt(p.weight),
                            w: Number(p.weight),
                            maxPerSide: Math.floor(clampInt(p.available) / 2),
                            hasOddRemainder: clampInt(p.available) % 2 === 1,
                        }))
                        .filter(
                            (t) =>
                                Number.isFinite(t.wI) &&
                                t.wI > 0 &&
                                t.maxPerSide > 0
                        )
                        .sort((a, b) => b.wI - a.wI);

                    let maxSumI = 0;
                    for (const t of types) maxSumI += t.wI * t.maxPerSide;
                    if (maxSumI < needPerSideI) return { kind: "no-solution" };

                    const greedy = (() => {
                        let sumI = 0;
                        let platesCount = 0;
                        let distinct = 0;
                        const usageCounts = new Array(types.length).fill(0);

                        for (let i = 0; i < types.length; i++) {
                            if (sumI >= needPerSideI) break;
                            const t = types[i];
                            const remainingI = Math.max(0, needPerSideI - sumI);
                            const take = Math.min(
                                t.maxPerSide,
                                Math.ceil(remainingI / t.wI)
                            );
                            if (take > 0) {
                                usageCounts[i] = take;
                                sumI += take * t.wI;
                                platesCount += take;
                                distinct++;
                            }
                        }
                        if (sumI < needPerSideI) return null;
                        return {
                            sumI,
                            platesPerSide: platesCount,
                            distinct,
                            usageCounts,
                        };
                    })();

                    if (!greedy) return { kind: "no-solution" };

                    let bestOverI = greedy.sumI - needPerSideI;
                    let bestPlatesPerSide = greedy.platesPerSide;
                    let bestSolutions = [greedy.usageCounts];
                    const seenSolutions = new Set();
                    seenSolutions.add(greedy.usageCounts.join(","));

                    const usage = new Array(types.length).fill(0);

                    function dfs(i, sumI, platesPerSide, distinct) {
                        if (sumI >= needPerSideI) {
                            const overI = sumI - needPerSideI;
                            if (
                                overI < bestOverI ||
                                (overI === bestOverI &&
                                    platesPerSide < bestPlatesPerSide)
                            ) {
                                bestOverI = overI;
                                bestPlatesPerSide = platesPerSide;
                                bestSolutions = [usage.slice()];
                                seenSolutions.clear();
                                seenSolutions.add(usage.join(","));
                            } else if (
                                overI === bestOverI &&
                                platesPerSide === bestPlatesPerSide
                            ) {
                                const key = usage.join(",");
                                if (!seenSolutions.has(key)) {
                                    seenSolutions.add(key);
                                    bestSolutions.push(usage.slice());
                                }
                            }
                            return;
                        }
                        if (i >= types.length) return;

                        const t = types[i];

                        const capSumI = needPerSideI + bestOverI;
                        const byBest = Math.ceil((capSumI - sumI) / t.wI);
                        const maxUse = Math.max(
                            0,
                            Math.min(t.maxPerSide, byBest)
                        );

                        for (let c = maxUse; c >= 0; c--) {
                            usage[i] = c;

                            const newSumI = sumI + c * t.wI;
                            const newPlates = platesPerSide + c;
                            const newDistinct = distinct + (c ? 1 : 0);

                            if (newSumI >= needPerSideI) {
                                const overI = newSumI - needPerSideI;
                                if (overI > bestOverI) continue;
                                if (
                                    overI === bestOverI &&
                                    newPlates > bestPlatesPerSide
                                )
                                    continue;
                            }

                            dfs(i + 1, newSumI, newPlates, newDistinct);
                        }
                        usage[i] = 0;
                    }

                    dfs(0, 0, 0, 0);

                    const allUsagePerSide = bestSolutions.map((usageCounts) => {
                        const usagePerSide = [];
                        for (let i = 0; i < types.length; i++) {
                            const c = usageCounts[i];
                            if (c > 0)
                                usagePerSide.push({
                                    weight: types[i].w,
                                    perSideCount: c,
                                });
                        }
                        return usagePerSide;
                    });

                    const bestSumI = needPerSideI + bestOverI;
                    const achievedTotalI = barI + 2 * bestSumI;
                    const achievedTotal = fromInt(achievedTotalI);
                    const overBy = achievedTotal - targetTotal;

                    const hasOdd = plates.some(
                        (p) => clampInt(p.available) % 2 === 1
                    );

                    return {
                        kind: "ok",
                        targetTotal,
                        achievedTotal,
                        overBy,
                        allUsagePerSide,
                        noteOddPairsIgnored: hasOdd,
                    };
                }

                function renderResults(r) {
                    if (
                        el.target.value === "" ||
                        el.bar.value === "" ||
                        r.kind === "invalid"
                    ) {
                        el.results.innerHTML = '<span class="muted">&mdash;</span>';
                        return;
                    }
                    if (r.kind === "no-solution") {
                        el.results.innerHTML = "<strong>No solution</strong>";
                        return;
                    }

                    const allUsage = r.allUsagePerSide || [r.usagePerSide];

                    const perSideLines = allUsage.map((usagePerSide) => {
                        const perSide = [];
                        for (const u of usagePerSide)
                            for (let i = 0; i < u.perSideCount; i++)
                                perSide.push(fmt(u.weight));
                        return perSide.length ? perSide.join(" + ") : "(no plates)";
                    });

                    const totalPlateCount = allUsage[0].reduce(
                        (sum, u) => sum + u.perSideCount * 2,
                        0
                    );

                    const exact = Math.abs(r.overBy) <= 1e-9;

                    const noteBelowBar =
                        r.kind === "below-bar"
                            ? `<div class="muted" style="font-size:0.8rem">Target below bar; minimum is bar alone.</div>`
                            : "";
                    const notePairs = r.noteOddPairsIgnored
                        ? `<div class="muted" style="font-size:0.8rem">Only pairs usable; odd plates ignored.</div>`
                        : "";

                    const perSideHtml = perSideLines
                        .map(
                            (line) =>
                                `<div class="result-line mono">Per side: ${line}</div>`
                        )
                        .join("");

                    el.results.innerHTML = `
                        <div class="result-main mono">= ${fmt(r.achievedTotal)}</div>
                        ${perSideHtml}
                        <div class="result-line muted">Total: ${totalPlateCount} plates</div>
                        ${noteBelowBar}
                        ${notePairs}
                        ${exact ? "" : `<div class="result-line danger">Over by: <span class="mono">${fmt(r.overBy)}</span></div>`}
                    `;
                }

                function renderInventory() {
                    el.inventory.textContent = "";
                    const frag = document.createDocumentFragment();

                    for (const p of state.plates) {
                        const row = document.createElement("div");
                        row.className = "plate-row";
                        row.dataset.id = p.id;

                        const w = document.createElement("div");
                        w.className = "mono";
                        w.innerHTML = `<strong>${fmt(p.weight)}</strong>`;

                        const a = document.createElement("div");
                        const input = document.createElement("input");
                        input.type = "number";
                        input.inputMode = "numeric";
                        input.step = "2";
                        input.min = "0";
                        input.className = "mono";
                        input.value = String(p.available);
                        input.dataset.action = "setAvailable";
                        input.setAttribute(
                            "aria-label",
                            `Available for ${fmt(p.weight)}`
                        );
                        a.append(input);

                        const x = document.createElement("div");
                        const btn = document.createElement("button");
                        btn.type = "button";
                        btn.dataset.action = "removePlate";
                        btn.setAttribute(
                            "aria-label",
                            `Remove ${fmt(p.weight)} plate`
                        );
                        btn.textContent = "×";
                        x.append(btn);

                        row.append(w, a, x);
                        frag.append(row);
                    }

                    el.inventory.append(frag);
                }

                function recalcAndRender() {
                    const targetStr = el.target.value;
                    const barStr = el.bar.value;

                    const target = parseLocaleNumber(targetStr);
                    const bar = parseLocaleNumber(barStr);

                    if (
                        targetStr === "" ||
                        barStr === "" ||
                        !Number.isFinite(target) ||
                        !Number.isFinite(bar)
                    ) {
                        renderResults({ kind: "invalid" });
                        return;
                    }

                    renderResults(computeBest(target, bar, state.plates));
                }

                let debounceTimer = 0;
                function scheduleRecalc() {
                    clearTimeout(debounceTimer);
                    debounceTimer = setTimeout(() => {
                        save();
                        recalcAndRender();
                    }, 60);
                }

                function addOrMergePlate(weight, available) {
                    const w = parseLocaleNumber(weight);
                    if (!Number.isFinite(w) || !(w > 0)) return false;

                    const a = clampInt(available === "" ? 0 : available);

                    const existing = state.plates.find(
                        (p) => toInt(p.weight) === toInt(w)
                    );
                    if (existing) {
                        existing.available = a;
                    } else {
                        state.plates.push({
                            id: uid(),
                            weight: w,
                            available: a,
                        });
                        state.plates.sort(byWeightDesc);
                    }
                    return true;
                }

                function submitNewPlate() {
                    const ok = addOrMergePlate(
                        el.newWeight.value,
                        el.newAvailable.value
                    );
                    if (!ok) {
                        el.newWeight.focus();
                        return;
                    }
                    el.newWeight.value = "";
                    el.newWeight.focus();
                    renderInventory();
                    scheduleRecalc();
                }

                function wire() {
                    el.target.addEventListener("input", () => {
                        state.targetWeight = el.target.value;
                        scheduleRecalc();
                    });

                    el.bar.addEventListener("input", () => {
                        state.barWeight =
                            el.bar.value === ""
                                ? ""
                                : parseLocaleNumber(el.bar.value);
                        scheduleRecalc();
                    });

                    el.clearTarget.addEventListener("click", () => {
                        el.target.value = "";
                        state.targetWeight = "";
                        el.target.focus();
                        scheduleRecalc();
                    });

                    el.clearBar.addEventListener("click", () => {
                        el.bar.value = "";
                        state.barWeight = "";
                        el.bar.focus();
                        scheduleRecalc();
                    });

                    el.addPlate.addEventListener("click", submitNewPlate);

                    el.reset.addEventListener("click", () => {
                        localStorage.removeItem(STORAGE_KEY);
                        resetStateToDefaults();
                        syncInputs();
                        renderInventory();
                        recalcAndRender();
                        save();
                    });

                    el.inventory.addEventListener("input", (e) => {
                        const row = e.target.closest(".plate-row");
                        if (!row) return;

                        const p = state.plates.find(
                            (x) => x.id === row.dataset.id
                        );
                        if (!p) return;

                        if (e.target.dataset.action === "setAvailable") {
                            p.available = clampInt(e.target.value);
                            scheduleRecalc();
                        }
                    });

                    el.inventory.addEventListener("focusout", (e) => {
                        if (e.target?.dataset?.action !== "setAvailable")
                            return;

                        const row = e.target.closest(".plate-row");
                        if (!row) return;

                        const p = state.plates.find(
                            (x) => x.id === row.dataset.id
                        );
                        if (!p) return;

                        const n = clampInt(e.target.value);
                        const even = n - (n % 2);
                        p.available = even;

                        if (e.target.value !== String(even)) {
                            e.target.value = String(even);
                        }

                        scheduleRecalc();
                    });

                    el.inventory.addEventListener("click", (e) => {
                        const btn =
                            e.target.closest && e.target.closest("button");
                        if (!btn) return;

                        const row = btn.closest(".plate-row");
                        if (!row) return;

                        if (btn.dataset.action === "removePlate") {
                            const id = row.dataset.id;
                            state.plates = state.plates.filter(
                                (p) => p.id !== id
                            );
                            renderInventory();
                            scheduleRecalc();
                        }
                    });

                    document.addEventListener("keydown", (e) => {
                        if (e.key !== "Escape") return;
                        const a = document.activeElement;
                        if (a === el.target) el.clearTarget.click();
                        else if (a === el.bar) el.clearBar.click();
                        else if (a === el.newWeight) el.newWeight.value = "";
                        else if (a === el.newAvailable)
                            el.newAvailable.value = "";
                    });
                }

                load();
                syncInputs();
                renderInventory();
                wire();
                recalcAndRender();
            })();
        </script>
    </body>
</html>
